-- 
-- Tests multiple commands in transactions where
-- there is foreign key relation between reference
-- tables and distributed tables
--
CREATE SCHEMA test_fkey_to_ref_in_tx;
SET search_path TO 'test_fkey_to_ref_in_tx';
SET citus.next_shard_id TO 2380000;
SET citus.next_placement_id TO 2380000;
SET citus.shard_replication_factor TO 1;
CREATE TABLE referece_table(id int PRIMARY KEY);
SELECT create_reference_table('referece_table');
 create_reference_table 
------------------------
 
(1 row)

CREATE TABLE on_update_fkey_table(id int PRIMARY KEY, value_1 int);
SELECT create_distributed_table('on_update_fkey_table', 'id');
 create_distributed_table 
--------------------------
 
(1 row)

CREATE TABLE unrelated_dist_table(id int PRIMARY KEY, value_1 int);
SELECT create_distributed_table('unrelated_dist_table', 'id');
 create_distributed_table 
--------------------------
 
(1 row)

ALTER TABLE on_update_fkey_table ADD CONSTRAINT fkey FOREIGN KEY(value_1) REFERENCES referece_table(id) ON UPDATE CASCADE;
INSERT INTO referece_table SELECT i FROM generate_series(0, 100) i;
INSERT INTO on_update_fkey_table SELECT i, i % 100  FROM generate_series(0, 1000) i;
INSERT INTO unrelated_dist_table SELECT i, i % 100  FROM generate_series(0, 1000) i;
-- in order to see when the mode automatically swithces to sequential execution
SET client_min_messages TO DEBUG1;
-- case 1.1: SELECT to a reference table is followed by a parallel SELECT to a distributed table
BEGIN;
	SELECT count(*) FROM referece_table;
 count 
-------
   101
(1 row)

	SELECT count(*) FROM on_update_fkey_table;
 count 
-------
  1001
(1 row)

ROLLBACK;
-- case 1.2: SELECT to a reference table is followed by a multiple router SELECTs to a distributed table
BEGIN;	
	SELECT count(*) FROM referece_table;
 count 
-------
   101
(1 row)

	SELECT count(*) FROM on_update_fkey_table WHERE id = 15;
 count 
-------
     1
(1 row)

	SELECT count(*) FROM on_update_fkey_table WHERE id = 16;
 count 
-------
     1
(1 row)

	SELECT count(*) FROM on_update_fkey_table WHERE id = 17;
 count 
-------
     1
(1 row)

	SELECT count(*) FROM on_update_fkey_table WHERE id = 18;
 count 
-------
     1
(1 row)

	
ROLLBACK;
-- case 1.3: SELECT to a reference table is followed by a multi-shard UPDATE to a distributed table
BEGIN;	
	SELECT count(*) FROM referece_table;
 count 
-------
   101
(1 row)

	UPDATE on_update_fkey_table SET value_1 = 16 WHERE value_1 = 15;
ROLLBACK;
-- case 1.4: SELECT to a reference table is followed by a multiple sing-shard UPDATE to a distributed table
BEGIN;	
	SELECT count(*) FROM referece_table;
 count 
-------
   101
(1 row)

	UPDATE on_update_fkey_table SET value_1 = 16 WHERE id = 15;
	UPDATE on_update_fkey_table SET value_1 = 16 WHERE id = 16;
	UPDATE on_update_fkey_table SET value_1 = 16 WHERE id = 17;
	UPDATE on_update_fkey_table SET value_1 = 16 WHERE id = 18;
ROLLBACK;
-- case 1.5: SELECT to a reference table is followed by a DDL that touches fkey column
BEGIN;	
	SELECT count(*) FROM referece_table;
 count 
-------
   101
(1 row)

	ALTER TABLE on_update_fkey_table ALTER COLUMN value_1 SET DATA TYPE bigint;
DEBUG:  rewriting table "on_update_fkey_table"
DEBUG:  building index "on_update_fkey_table_pkey" on table "on_update_fkey_table"
DEBUG:  validating foreign key constraint "fkey"
ROLLBACK;
-- case 1.6: SELECT to a reference table is followed by an unrelated DDL
BEGIN;	
	SELECT count(*) FROM referece_table;
 count 
-------
   101
(1 row)

	ALTER TABLE on_update_fkey_table ADD COLUMN X INT;
ROLLBACK;
-- case 1.6: SELECT to a reference table is followed by a COPY
BEGIN;
	SELECT count(*) FROM referece_table;
 count 
-------
   101
(1 row)

	COPY on_update_fkey_table FROM STDIN WITH CSV;
ROLLBACK;
-- case 2.1: UPDATE to a reference table is followed by a multi-shard SELECT
BEGIN;
	UPDATE referece_table SET id = 101 WHERE id = 99;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might have cascaded to hash distributed relations via foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
	SELECT count(*) FROM on_update_fkey_table WHERE value_1 = 99;
 count 
-------
     0
(1 row)

	SELECT count(*) FROM on_update_fkey_table WHERE value_1 = 101;
 count 
-------
    10
(1 row)

ROLLBACK;
-- case 2.2: UPDATE to a reference table is followed by multiple router SELECT
BEGIN;
	UPDATE referece_table SET id = 101 WHERE id = 99;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might have cascaded to hash distributed relations via foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
	SELECT count(*) FROM on_update_fkey_table WHERE value_1 = 101 AND id = 99;
 count 
-------
     1
(1 row)

	SELECT count(*) FROM on_update_fkey_table WHERE value_1 = 101 AND id = 199;
 count 
-------
     1
(1 row)

	SELECT count(*) FROM on_update_fkey_table WHERE value_1 = 101 AND id = 299;
 count 
-------
     1
(1 row)

	SELECT count(*) FROM on_update_fkey_table WHERE value_1 = 101 AND id = 399;
 count 
-------
     1
(1 row)

ROLLBACK;
-- case 2.3: UPDATE to a reference table is followed by a multi-shard UPDATE
BEGIN;
	UPDATE referece_table SET id = 101 WHERE id = 99;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might have cascaded to hash distributed relations via foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
	UPDATE on_update_fkey_table SET value_1 = 15;
ROLLBACK;
-- case 2.4: UPDATE to a reference table is followed by multiple router UPDATEs
BEGIN;
	UPDATE referece_table SET id = 101 WHERE id = 99;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might have cascaded to hash distributed relations via foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
	UPDATE on_update_fkey_table SET value_1 = 101 WHERE id = 1;
	UPDATE on_update_fkey_table SET value_1 = 101 WHERE id = 2;
	UPDATE on_update_fkey_table SET value_1 = 101 WHERE id = 3;
	UPDATE on_update_fkey_table SET value_1 = 101 WHERE id = 4;
ROLLBACK;
-- case 2.5: UPDATE to a reference table is followed by a DDL that touches fkey column
BEGIN;
	UPDATE referece_table SET id = 101 WHERE id = 99;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might have cascaded to hash distributed relations via foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
	ALTER TABLE on_update_fkey_table ALTER COLUMN value_1 SET DATA TYPE bigint;
DEBUG:  rewriting table "on_update_fkey_table"
DEBUG:  building index "on_update_fkey_table_pkey" on table "on_update_fkey_table"
DEBUG:  validating foreign key constraint "fkey"
ROLLBACK;
-- case 2.6: UPDATE to a reference table is followed by an unrelated DDL
BEGIN;
	UPDATE referece_table SET id = 101 WHERE id = 99;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might have cascaded to hash distributed relations via foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
	ALTER TABLE on_update_fkey_table ADD COLUMN value_1_X INT;
ROLLBACK;
-- case 2.7: UPDATE to a reference table is followed by COPY
BEGIN;
	UPDATE referece_table SET id = 101 WHERE id = 99;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might have cascaded to hash distributed relations via foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
	COPY on_update_fkey_table FROM STDIN WITH CSV;
ERROR:  cannot execute parallel COPY on relation "on_update_fkey_table" since it holds conflicting locks via foreign keys on reference relation "referece_table" due to a previous "DML" access in the same transaction 
CONTEXT:  COPY on_update_fkey_table, line 2: "1002,99"
ROLLBACK;
-- case 2.8: UPDATE to a reference table is followed by TRUNCATE
BEGIN;
	UPDATE referece_table SET id = 101 WHERE id = 99;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might have cascaded to hash distributed relations via foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
	TRUNCATE on_update_fkey_table;
DEBUG:  building index "on_update_fkey_table_pkey" on table "on_update_fkey_table"
ROLLBACK;
-- case 3.1: an unrelated DDL to a reference table is followed by a real-time SELECT
BEGIN;
	ALTER TABLE referece_table ALTER COLUMN id SET DEFAULT 1001;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might have cascaded to hash distributed relations via foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
	SELECT count(*) FROM on_update_fkey_table;
 count 
-------
  1001
(1 row)

ROLLBACK;
-- case 3.2: DDL that touches fkey column to a reference table is followed by a real-time SELECT
BEGIN;
	ALTER TABLE referece_table ALTER COLUMN id SET DATA TYPE int;
	SELECT count(*) FROM on_update_fkey_table;
 count 
-------
  1001
(1 row)

ROLLBACK;
-- case 3.3: DDL to a reference table followed by a multi shard UPDATE
BEGIN;
	ALTER TABLE referece_table ALTER COLUMN id SET DEFAULT 1001;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might have cascaded to hash distributed relations via foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
	UPDATE on_update_fkey_table SET value_1 = 5 WHERE id != 11;
ROLLBACK;
-- case 3.4: DDL to a reference table followed by multiple router UPDATEs
BEGIN;
	ALTER TABLE referece_table ALTER COLUMN id SET DEFAULT 1001;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might have cascaded to hash distributed relations via foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
	UPDATE on_update_fkey_table SET value_1 = 98 WHERE id = 1;
	UPDATE on_update_fkey_table SET value_1 = 98 WHERE id = 2;
	UPDATE on_update_fkey_table SET value_1 = 98 WHERE id = 3;
	UPDATE on_update_fkey_table SET value_1 = 98 WHERE id = 4;
ROLLBACK;
-- case 3.5: DDL to reference table followed by a DDL to dist table
BEGIN;
	ALTER TABLE referece_table ALTER COLUMN id SET DATA TYPE smallint;
DEBUG:  rewriting table "referece_table"
DEBUG:  building index "referece_table_pkey" on table "referece_table"
DEBUG:  validating foreign key constraint "fkey"
	CREATE INDEX fkey_test_index_1 ON on_update_fkey_table(value_1);
DEBUG:  building index "fkey_test_index_1" on table "on_update_fkey_table"
ROLLBACK;
-- case 4.6: DDL to reference table followed by a DDL to dist table, both touching fkey columns
BEGIN;
	ALTER TABLE referece_table ALTER COLUMN id SET DATA TYPE smallint;
DEBUG:  rewriting table "referece_table"
DEBUG:  building index "referece_table_pkey" on table "referece_table"
DEBUG:  validating foreign key constraint "fkey"
	ALTER TABLE on_update_fkey_table ALTER COLUMN value_1 SET DATA TYPE smallint;
DEBUG:  rewriting table "on_update_fkey_table"
DEBUG:  building index "on_update_fkey_table_pkey" on table "on_update_fkey_table"
DEBUG:  validating foreign key constraint "fkey"
ROLLBACK;
-- case 3.7: DDL to a reference table is followed by COPY
BEGIN;
	ALTER TABLE referece_table  ADD COLUMN X int;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might have cascaded to hash distributed relations via foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
	COPY on_update_fkey_table FROM STDIN WITH CSV;
ERROR:  cannot execute parallel COPY on relation "on_update_fkey_table" since it holds conflicting locks via foreign keys on reference relation "referece_table" due to a previous "DDL" access in the same transaction 
CONTEXT:  COPY on_update_fkey_table, line 2: "1002,99"
ROLLBACK;
-- case 3.8: DDL to a reference table is followed by TRUNCATE
BEGIN;
	ALTER TABLE referece_table  ADD COLUMN X int;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might have cascaded to hash distributed relations via foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
	TRUNCATE on_update_fkey_table;
DEBUG:  building index "on_update_fkey_table_pkey" on table "on_update_fkey_table"
ROLLBACK;
-- case 3.9: DDL to a reference table is followed by TRUNCATE
BEGIN;
	ALTER TABLE referece_table ALTER COLUMN id SET DATA TYPE smallint;
DEBUG:  rewriting table "referece_table"
DEBUG:  building index "referece_table_pkey" on table "referece_table"
DEBUG:  validating foreign key constraint "fkey"
	TRUNCATE on_update_fkey_table;
DEBUG:  building index "on_update_fkey_table_pkey" on table "on_update_fkey_table"
ROLLBACK;
-----
--- Now, start testing the other way araound
-----
-- case 4.1: SELECT to a dist table is follwed by a SELECT to a reference table
BEGIN;
	SELECT count(*) FROM on_update_fkey_table WHERE value_1 = 99;
 count 
-------
    10
(1 row)

	SELECT count(*) FROM referece_table;
 count 
-------
   101
(1 row)

ROLLBACK;
-- case 4.2: SELECT to a dist table is follwed by a DML to a reference table
BEGIN;
	SELECT count(*) FROM on_update_fkey_table WHERE value_1 = 99;
 count 
-------
    10
(1 row)

	UPDATE referece_table SET id = 101 WHERE id = 99;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might have cascaded to hash distributed relations via foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
ERROR:  attempt to set query execution mode to sequential failed since a parallel query has already been executed in the same transaction
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- case 4.3: SELECT to a dist table is follwed by an unrelated DDL to a reference table
BEGIN;
	SELECT count(*) FROM on_update_fkey_table WHERE value_1 = 99;
 count 
-------
    10
(1 row)

	ALTER TABLE referece_table ADD COLUMN X INT;
ERROR:  cannot execute "DDL" on relation "referece_table" since it holds conflicting locks on relation "on_update_fkey_table" due to a previous parallel "SELECT" access in the same transaction 
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- case 4.4: SELECT to a dist table is follwed by a DDL to a reference table
BEGIN;
	SELECT count(*) FROM on_update_fkey_table WHERE value_1 = 99;
 count 
-------
    10
(1 row)

	ALTER TABLE referece_table ALTER COLUMN id SET DATA TYPE smallint;
DEBUG:  rewriting table "referece_table"
DEBUG:  building index "referece_table_pkey" on table "referece_table"
DEBUG:  validating foreign key constraint "fkey"
ERROR:  cannot execute "DDL" on relation "referece_table" since it holds conflicting locks on relation "on_update_fkey_table" due to a previous parallel "SELECT" access in the same transaction 
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- case 4.5: SELECT to a dist table is follwed by a TRUNCATE
BEGIN;
	SELECT count(*) FROM on_update_fkey_table WHERE value_1 = 99;
 count 
-------
    10
(1 row)

	TRUNCATE referece_table CASCADE;
NOTICE:  truncate cascades to table "on_update_fkey_table"
ERROR:  cannot execute "DDL" on relation "referece_table" since it holds conflicting locks on relation "on_update_fkey_table" due to a previous parallel "SELECT" access in the same transaction 
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- case 4.6: Router SELECT to a dist table is followed by a TRUNCATE
BEGIN;
	SELECT count(*) FROM on_update_fkey_table WHERE id = 9;
 count 
-------
     1
(1 row)

	TRUNCATE referece_table CASCADE;
NOTICE:  truncate cascades to table "on_update_fkey_table"
DEBUG:  truncate cascades to table "on_update_fkey_table_2380002"
DETAIL:  NOTICE from localhost:57638
DEBUG:  truncate cascades to table "on_update_fkey_table_2380004"
DETAIL:  NOTICE from localhost:57638
DEBUG:  truncate cascades to table "on_update_fkey_table_2380001"
DETAIL:  NOTICE from localhost:57637
DEBUG:  truncate cascades to table "on_update_fkey_table_2380003"
DETAIL:  NOTICE from localhost:57637
DEBUG:  building index "referece_table_pkey" on table "referece_table"
DEBUG:  building index "on_update_fkey_table_pkey" on table "on_update_fkey_table"
ROLLBACK;
-- case 5.1: Parallel UPDATE on distributed table follow by a SELECT
BEGIN;
	UPDATE on_update_fkey_table SET value_1 = 16 WHERE value_1 = 15;
	SELECT count(*) FROM referece_table;
 count 
-------
   101
(1 row)

ROLLBACK;
-- case 5.2: Parallel UPDATE on distributed table follow by a UPDATE
BEGIN;
	UPDATE on_update_fkey_table SET value_1 = 16 WHERE value_1 = 15;
	UPDATE referece_table SET id = 160 WHERE id = 15;
ERROR:  cannot execute "DML" on relation "referece_table" since it holds conflicting locks on relation "on_update_fkey_table" due to a previous parallel "DML" access in the same transaction 
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- case 5.3: Parallel UPDATE on distributed table follow by an unrelated DDL on reference table
BEGIN;
	UPDATE on_update_fkey_table SET value_1 = 16 WHERE value_1 = 15;
	ALTER TABLE referece_table ADD COLUMN X INT;
ERROR:  cannot execute "DDL" on relation "referece_table" since it holds conflicting locks on relation "on_update_fkey_table" due to a previous parallel "DML" access in the same transaction 
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- case 5.4: Parallel UPDATE on distributed table follow by a related DDL on reference table
-- FIXME: Can we do better?
BEGIN;
	UPDATE on_update_fkey_table SET value_1 = 16 WHERE value_1 = 15;
	ALTER TABLE referece_table ALTER COLUMN id SET DATA TYPE smallint;
DEBUG:  rewriting table "referece_table"
DEBUG:  building index "referece_table_pkey" on table "referece_table"
DEBUG:  validating foreign key constraint "fkey"
ERROR:  cannot perform DDL on placement 2380001, which has been read over multiple connections
ROLLBACK;
-- case 6:1: Unrelated parallel DDL on distributed table followed by SELECT on ref. table
BEGIN;
	ALTER TABLE on_update_fkey_table ADD COLUMN X int;
	SELECT count(*) FROM referece_table;
ERROR:  cannot execute "SELECT" on relation "referece_table" since it holds conflicting locks on relation "on_update_fkey_table" due to a previous parallel "DDL" access in the same transaction 
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- case 6:2: Related parallel DDL on distributed table followed by SELECT on ref. table
BEGIN;
	ALTER TABLE on_update_fkey_table ALTER COLUMN value_1 SET DATA TYPE smallint;
DEBUG:  rewriting table "on_update_fkey_table"
DEBUG:  building index "on_update_fkey_table_pkey" on table "on_update_fkey_table"
DEBUG:  validating foreign key constraint "fkey"
	UPDATE referece_table SET id = 160 WHERE id = 15;
ROLLBACK;
-- case 6:3: Unrelated parallel DDL on distributed table followed by UPDATE on ref. table
BEGIN;
	ALTER TABLE on_update_fkey_table ADD COLUMN X int;
	SELECT count(*) FROM referece_table;
ERROR:  cannot execute "SELECT" on relation "referece_table" since it holds conflicting locks on relation "on_update_fkey_table" due to a previous parallel "DDL" access in the same transaction 
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- case 6:4: Related parallel DDL on distributed table followed by SELECT on ref. table
BEGIN;
	ALTER TABLE on_update_fkey_table ADD COLUMN X int;
	UPDATE referece_table SET id = 160 WHERE id = 15;
ERROR:  cannot execute "SELECT" on relation "referece_table" since it holds conflicting locks on relation "on_update_fkey_table" due to a previous parallel "DDL" access in the same transaction 
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- case 6:5: Unrelated parallel DDL on distributed table followed by unrelated DDL on ref. table
BEGIN;
	ALTER TABLE on_update_fkey_table ADD COLUMN X int;
	ALTER TABLE referece_table ADD COLUMN X int;
ERROR:  cannot execute "DDL" on relation "referece_table" since it holds conflicting locks on relation "on_update_fkey_table" due to a previous parallel "DDL" access in the same transaction 
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- case 6:6: Unrelated parallel DDL on distributed table followed by related DDL on ref. table
BEGIN;
	ALTER TABLE on_update_fkey_table ADD COLUMN X int;
	ALTER TABLE on_update_fkey_table ALTER COLUMN value_1 SET DATA TYPE smallint;
DEBUG:  rewriting table "on_update_fkey_table"
DEBUG:  building index "on_update_fkey_table_pkey" on table "on_update_fkey_table"
DEBUG:  validating foreign key constraint "fkey"
ERROR:  cannot execute "SELECT" on relation "referece_table" since it holds conflicting locks on relation "on_update_fkey_table" due to a previous parallel "DDL" access in the same transaction 
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
CONTEXT:  SQL statement "SELECT fk."value_1" FROM ONLY "test_fkey_to_ref_in_tx"."on_update_fkey_table" fk LEFT OUTER JOIN ONLY "test_fkey_to_ref_in_tx"."referece_table" pk ON ( pk."id" OPERATOR(pg_catalog.=) fk."value_1") WHERE pk."id" IS NULL AND (fk."value_1" IS NOT NULL)"
ROLLBACK;
-- some more extensive tests
-- UPDATE on dist table is followed by DELETE to reference table
BEGIN;
	UPDATE on_update_fkey_table SET value_1 = 5 WHERE id != 11;
	DELETE FROM referece_table  WHERE id = 99;
ERROR:  cannot execute "DML" on relation "referece_table" since it holds conflicting locks on relation "on_update_fkey_table" due to a previous parallel "DML" access in the same transaction 
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- an unrelated update followed by update on dist table and update
-- on reference table
BEGIN;
	UPDATE unrelated_dist_table SET value_1 = 15;
	UPDATE on_update_fkey_table SET value_1 = 5 WHERE id != 11;
	UPDATE referece_table SET id = 101 WHERE id = 99;
ERROR:  cannot execute "DML" on relation "referece_table" since it holds conflicting locks on relation "on_update_fkey_table" due to a previous parallel "DML" access in the same transaction 
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- an unrelated update followed by update on the reference table and update
-- on the cascading distributed table
-- note that the UPDATE on the reference table will try to set the execution
-- mode to sequential, which will fail since there is an already opened 
-- parallel connections
BEGIN;
	UPDATE unrelated_dist_table SET value_1 = 15;
	UPDATE referece_table SET id = 101 WHERE id = 99;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might have cascaded to hash distributed relations via foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
ERROR:  attempt to set query execution mode to sequential failed since a parallel query has already been executed in the same transaction
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
	UPDATE on_update_fkey_table SET value_1 = 5 WHERE id != 11;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
ROLLBACK;
BEGIN;
	CREATE TABLE test_table_1(id int PRIMARY KEY);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_1_pkey" for table "test_table_1"
DEBUG:  building index "test_table_1_pkey" on table "test_table_1"
	SELECT create_reference_table('test_table_1');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_reference_table 
------------------------
 
(1 row)

	CREATE TABLE test_table_2(id int PRIMARY KEY, value_1 int, FOREIGN KEY(value_1) REFERENCES test_table_1(id));
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_2_pkey" for table "test_table_2"
DEBUG:  building index "test_table_2_pkey" on table "test_table_2"
	SELECT create_distributed_table('test_table_2', 'id');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_distributed_table 
--------------------------
 
(1 row)

	DROP TABLE test_table_1 CASCADE;
NOTICE:  drop cascades to constraint test_table_2_value_1_fkey on table test_table_2
DEBUG:  EventTriggerInvoke 20179
DEBUG:  drop cascades to 2 other objects
DETAIL:  drop cascades to constraint test_table_2_value_1_fkey_2380011 on table test_fkey_to_ref_in_tx.test_table_2_2380011
drop cascades to constraint test_table_2_value_1_fkey_2380013 on table test_fkey_to_ref_in_tx.test_table_2_2380013
DETAIL:  NOTICE from localhost:57638
CONTEXT:  SQL statement "SELECT master_drop_all_shards(v_obj.objid, v_obj.schema_name, v_obj.object_name)"
PL/pgSQL function citus_drop_trigger() line 17 at PERFORM
DEBUG:  drop cascades to 2 other objects
DETAIL:  drop cascades to constraint test_table_2_value_1_fkey_2380010 on table test_fkey_to_ref_in_tx.test_table_2_2380010
drop cascades to constraint test_table_2_value_1_fkey_2380012 on table test_fkey_to_ref_in_tx.test_table_2_2380012
DETAIL:  NOTICE from localhost:57637
CONTEXT:  SQL statement "SELECT master_drop_all_shards(v_obj.objid, v_obj.schema_name, v_obj.object_name)"
PL/pgSQL function citus_drop_trigger() line 17 at PERFORM
ROLLBACK;
-- the fails since we're trying to switch sequential mode after
-- already executed a parallel query
BEGIN;
	CREATE TABLE test_table_1(id int PRIMARY KEY);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_1_pkey" for table "test_table_1"
DEBUG:  building index "test_table_1_pkey" on table "test_table_1"
	SELECT create_reference_table('test_table_1'); 
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_reference_table 
------------------------
 
(1 row)

	CREATE TABLE tt4(id int PRIMARY KEY, value_1 int, FOREIGN KEY(id) REFERENCES tt4(id));
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "tt4_pkey" for table "tt4"
DEBUG:  building index "tt4_pkey" on table "tt4"
	SELECT create_distributed_table('tt4', 'id');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_distributed_table 
--------------------------
 
(1 row)

	CREATE TABLE test_table_2(id int PRIMARY KEY, value_1 int, FOREIGN KEY(value_1) REFERENCES test_table_1(id), FOREIGN KEY(id) REFERENCES tt4(id));
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_2_pkey" for table "test_table_2"
DEBUG:  building index "test_table_2_pkey" on table "test_table_2"
	SELECT create_distributed_table('test_table_2', 'id');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
ERROR:  cannot distribute relation "test_table_2" in this transaction because it has a foreign key to a reference table
DETAIL:  If a hash distributed table has a foreign key to a reference table, it has to be created in sequential mode before any parallel commands have been executed in the same transaction
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
	DROP TABLE test_table_1 CASCADE;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
ROLLBACK;
-- same test with the above, but this time using
-- sequential mode, succeeds
BEGIN;
	SET LOCAL citus.multi_shard_modify_mode TO 'sequential';
	CREATE TABLE test_table_1(id int PRIMARY KEY);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_1_pkey" for table "test_table_1"
DEBUG:  building index "test_table_1_pkey" on table "test_table_1"
	SELECT create_reference_table('test_table_1'); 
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_reference_table 
------------------------
 
(1 row)

	CREATE TABLE tt4(id int PRIMARY KEY, value_1 int, FOREIGN KEY(id) REFERENCES tt4(id));
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "tt4_pkey" for table "tt4"
DEBUG:  building index "tt4_pkey" on table "tt4"
	SELECT create_distributed_table('tt4', 'id');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_distributed_table 
--------------------------
 
(1 row)

	CREATE TABLE test_table_2(id int PRIMARY KEY, value_1 int, FOREIGN KEY(value_1) REFERENCES test_table_1(id), FOREIGN KEY(id) REFERENCES tt4(id));
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_2_pkey" for table "test_table_2"
DEBUG:  building index "test_table_2_pkey" on table "test_table_2"
	SELECT create_distributed_table('test_table_2', 'id');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_distributed_table 
--------------------------
 
(1 row)

	DROP TABLE test_table_1 CASCADE;
NOTICE:  drop cascades to constraint test_table_2_value_1_fkey on table test_table_2
DEBUG:  EventTriggerInvoke 20179
DEBUG:  drop cascades to 2 other objects
DETAIL:  drop cascades to constraint test_table_2_value_1_fkey_2380025 on table test_fkey_to_ref_in_tx.test_table_2_2380025
drop cascades to constraint test_table_2_value_1_fkey_2380027 on table test_fkey_to_ref_in_tx.test_table_2_2380027
DETAIL:  NOTICE from localhost:57638
CONTEXT:  SQL statement "SELECT master_drop_all_shards(v_obj.objid, v_obj.schema_name, v_obj.object_name)"
PL/pgSQL function citus_drop_trigger() line 17 at PERFORM
DEBUG:  drop cascades to 2 other objects
DETAIL:  drop cascades to constraint test_table_2_value_1_fkey_2380024 on table test_fkey_to_ref_in_tx.test_table_2_2380024
drop cascades to constraint test_table_2_value_1_fkey_2380026 on table test_fkey_to_ref_in_tx.test_table_2_2380026
DETAIL:  NOTICE from localhost:57637
CONTEXT:  SQL statement "SELECT master_drop_all_shards(v_obj.objid, v_obj.schema_name, v_obj.object_name)"
PL/pgSQL function citus_drop_trigger() line 17 at PERFORM
ROLLBACK;
-- another test with ALTER TABLE fails since we're already opened
-- parallel connection via create_distributed_table(), later
-- adding foreign key to reference table fails
BEGIN;
	
	CREATE TABLE test_table_1(id int PRIMARY KEY);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_1_pkey" for table "test_table_1"
DEBUG:  building index "test_table_1_pkey" on table "test_table_1"
	SELECT create_reference_table('test_table_1');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_reference_table 
------------------------
 
(1 row)

	CREATE TABLE test_table_2(id int PRIMARY KEY, value_1 int);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_2_pkey" for table "test_table_2"
DEBUG:  building index "test_table_2_pkey" on table "test_table_2"
	SELECT create_distributed_table('test_table_2', 'id');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_distributed_table 
--------------------------
 
(1 row)

	ALTER TABLE test_table_2 ADD CONSTRAINT c_check FOREIGN KEY (value_1) REFERENCES test_table_1(id);
ERROR:  cannot execute "DDL" on relation "test_table_1" since it holds conflicting locks on relation "test_table_2" due to a previous parallel "DDL" access in the same transaction 
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
	DROP TABLE test_table_1, test_table_2;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
COMMIT;
-- same test with the above on sequential mode should work fine
BEGIN;
	
	SET LOCAL citus.multi_shard_modify_mode TO 'sequential';
	CREATE TABLE test_table_1(id int PRIMARY KEY);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_1_pkey" for table "test_table_1"
DEBUG:  building index "test_table_1_pkey" on table "test_table_1"
	SELECT create_reference_table('test_table_1');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_reference_table 
------------------------
 
(1 row)

	CREATE TABLE test_table_2(id int PRIMARY KEY, value_1 int);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_2_pkey" for table "test_table_2"
DEBUG:  building index "test_table_2_pkey" on table "test_table_2"
	SELECT create_distributed_table('test_table_2', 'id');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_distributed_table 
--------------------------
 
(1 row)

	ALTER TABLE test_table_2 ADD CONSTRAINT c_check FOREIGN KEY (value_1) REFERENCES test_table_1(id);
	DROP TABLE test_table_1, test_table_2;
DEBUG:  EventTriggerInvoke 20179
COMMIT;
-- similar test with the above, but this time the order of 
-- create_distributed_table and create_reference_table is
-- changed
BEGIN;
	CREATE TABLE test_table_2(id int PRIMARY KEY, value_1 int);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_2_pkey" for table "test_table_2"
DEBUG:  building index "test_table_2_pkey" on table "test_table_2"
	SELECT create_distributed_table('test_table_2', 'id');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_distributed_table 
--------------------------
 
(1 row)

	CREATE TABLE test_table_1(id int PRIMARY KEY);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_1_pkey" for table "test_table_1"
DEBUG:  building index "test_table_1_pkey" on table "test_table_1"
	SELECT create_reference_table('test_table_1');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_reference_table 
------------------------
 
(1 row)

	ALTER TABLE test_table_2 ADD CONSTRAINT c_check FOREIGN KEY (value_1) REFERENCES test_table_1(id);
ERROR:  cannot execute "DDL" on relation "test_table_1" since it holds conflicting locks on relation "test_table_2" due to a previous parallel "DDL" access in the same transaction 
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
	DROP TABLE test_table_1 CASCADE;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
ROLLBACK;
-- same test in sequential mode should succeed
BEGIN;
	SET LOCAL citus.multi_shard_modify_mode TO 'sequential';
	CREATE TABLE test_table_2(id int PRIMARY KEY, value_1 int);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_2_pkey" for table "test_table_2"
DEBUG:  building index "test_table_2_pkey" on table "test_table_2"
	SELECT create_distributed_table('test_table_2', 'id');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_distributed_table 
--------------------------
 
(1 row)

	CREATE TABLE test_table_1(id int PRIMARY KEY);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_1_pkey" for table "test_table_1"
DEBUG:  building index "test_table_1_pkey" on table "test_table_1"
	SELECT create_reference_table('test_table_1');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_reference_table 
------------------------
 
(1 row)

	ALTER TABLE test_table_2 ADD CONSTRAINT c_check FOREIGN KEY (value_1) REFERENCES test_table_1(id);
	DROP TABLE test_table_1 CASCADE;
NOTICE:  drop cascades to constraint c_check on table test_table_2
DEBUG:  EventTriggerInvoke 20179
DEBUG:  drop cascades to 2 other objects
DETAIL:  drop cascades to constraint c_check_2380044 on table test_fkey_to_ref_in_tx.test_table_2_2380044
drop cascades to constraint c_check_2380046 on table test_fkey_to_ref_in_tx.test_table_2_2380046
DETAIL:  NOTICE from localhost:57638
CONTEXT:  SQL statement "SELECT master_drop_all_shards(v_obj.objid, v_obj.schema_name, v_obj.object_name)"
PL/pgSQL function citus_drop_trigger() line 17 at PERFORM
DEBUG:  drop cascades to 2 other objects
DETAIL:  drop cascades to constraint c_check_2380043 on table test_fkey_to_ref_in_tx.test_table_2_2380043
drop cascades to constraint c_check_2380045 on table test_fkey_to_ref_in_tx.test_table_2_2380045
DETAIL:  NOTICE from localhost:57637
CONTEXT:  SQL statement "SELECT master_drop_all_shards(v_obj.objid, v_obj.schema_name, v_obj.object_name)"
PL/pgSQL function citus_drop_trigger() line 17 at PERFORM
ROLLBACK;
-- again a very similar test, but this time
-- a parallel SELECT is already executed before
-- setting the mode to sequential should fail
BEGIN;
	SELECT count(*) FROM on_update_fkey_table;
 count 
-------
  1001
(1 row)

	SET LOCAL citus.multi_shard_modify_mode TO 'sequential';
	CREATE TABLE test_table_2(id int PRIMARY KEY, value_1 int);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_2_pkey" for table "test_table_2"
DEBUG:  building index "test_table_2_pkey" on table "test_table_2"
	SELECT create_distributed_table('test_table_2', 'id');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
ERROR:  cannot distribute relation "test_table_2" in this transaction because it has a foreign key to a reference table
DETAIL:  If a hash distributed table has a foreign key to a reference table, it has to be created in sequential mode before any parallel commands have been executed in the same transaction
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
	CREATE TABLE test_table_1(id int PRIMARY KEY);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
	SELECT create_reference_table('test_table_1');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
	ALTER TABLE test_table_2 ADD CONSTRAINT c_check FOREIGN KEY (value_1) REFERENCES test_table_1(id);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
	DROP TABLE test_table_1 CASCADE;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
ROLLBACK;
-- make sure that we cannot create hash distributed tables with
-- foreign keys to reference tables when they have data in it
BEGIN;
	
	CREATE TABLE test_table_1(id int PRIMARY KEY);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_1_pkey" for table "test_table_1"
DEBUG:  building index "test_table_1_pkey" on table "test_table_1"
	INSERT INTO test_table_1 SELECT i FROM generate_series(0,100) i;
	CREATE TABLE test_table_2(id int PRIMARY KEY, value_1 int, FOREIGN KEY(value_1) REFERENCES test_table_1(id));
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_2_pkey" for table "test_table_2"
DEBUG:  building index "test_table_2_pkey" on table "test_table_2"
	INSERT INTO test_table_2 SELECT i, i FROM generate_series(0,100) i;
	SELECT create_reference_table('test_table_1');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "test_table_1" is modified, which might have cascaded to hash distributed relations via foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
NOTICE:  Copying data from local table...
DEBUG:  Copied 101 rows
 create_reference_table 
------------------------
 
(1 row)

	SELECT create_distributed_table('test_table_2', 'id');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
ERROR:  cannot distribute "test_table_2" in sequential mode because it is not empty
HINT:  If you have manually set citus.multi_shard_modify_mode to 'sequential', try with 'parallel' option. If that is not the case, try distributing local tables when they are empty.
	DROP TABLE test_table_2, test_table_1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
COMMIT;
-- the same test with above in sequential mode would still not work
-- since COPY cannot be executed in sequential mode
BEGIN;
	
	SET LOCAL citus.multi_shard_modify_mode TO 'sequential';
	CREATE TABLE test_table_1(id int PRIMARY KEY);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_1_pkey" for table "test_table_1"
DEBUG:  building index "test_table_1_pkey" on table "test_table_1"
	INSERT INTO test_table_1 SELECT i FROM generate_series(0,100) i;
	CREATE TABLE test_table_2(id int PRIMARY KEY, value_1 int, FOREIGN KEY(value_1) REFERENCES test_table_1(id));
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_2_pkey" for table "test_table_2"
DEBUG:  building index "test_table_2_pkey" on table "test_table_2"
	INSERT INTO test_table_2 SELECT i, i FROM generate_series(0,100) i;
	SELECT create_reference_table('test_table_1');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
NOTICE:  Copying data from local table...
DEBUG:  Copied 101 rows
 create_reference_table 
------------------------
 
(1 row)

	SELECT create_distributed_table('test_table_2', 'id');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
ERROR:  cannot distribute "test_table_2" in sequential mode because it is not empty
HINT:  If you have manually set citus.multi_shard_modify_mode to 'sequential', try with 'parallel' option. If that is not the case, try distributing local tables when they are empty.
	DROP TABLE test_table_2, test_table_1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
COMMIT; 
-- we should be able to execute and DML/DDL/SELECT after we've
-- switched to sequential via create_distributed_table
BEGIN;
	
	CREATE TABLE test_table_1(id int PRIMARY KEY);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_1_pkey" for table "test_table_1"
DEBUG:  building index "test_table_1_pkey" on table "test_table_1"
	CREATE TABLE test_table_2(id int PRIMARY KEY, value_1 int, FOREIGN KEY(value_1) REFERENCES test_table_1(id));
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_2_pkey" for table "test_table_2"
DEBUG:  building index "test_table_2_pkey" on table "test_table_2"
	SELECT create_reference_table('test_table_1');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "test_table_1" is modified, which might have cascaded to hash distributed relations via foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_reference_table 
------------------------
 
(1 row)

	SELECT create_distributed_table('test_table_2', 'id');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_distributed_table 
--------------------------
 
(1 row)

	-- and maybe some other test
	CREATE INDEX i1 ON test_table_1(id);
DEBUG:  building index "i1" on table "test_table_1"
	ALTER TABLE test_table_2 ADD CONSTRAINT check_val CHECK (id > 0);
DEBUG:  verifying table "test_table_2"
	SELECT count(*) FROM test_table_2;
 count 
-------
     0
(1 row)

	SELECT count(*) FROM test_table_1;
 count 
-------
     0
(1 row)

	UPDATE test_table_2 SET value_1 = 15;
	DROP TABLE test_table_2, test_table_1;
DEBUG:  EventTriggerInvoke 20179
DEBUG:  drop cascades to 2 other objects
DETAIL:  drop cascades to constraint test_table_2_value_1_fkey_2380052 on table test_fkey_to_ref_in_tx.test_table_2_2380052
drop cascades to constraint test_table_2_value_1_fkey_2380054 on table test_fkey_to_ref_in_tx.test_table_2_2380054
DETAIL:  NOTICE from localhost:57638
CONTEXT:  SQL statement "SELECT master_drop_all_shards(v_obj.objid, v_obj.schema_name, v_obj.object_name)"
PL/pgSQL function citus_drop_trigger() line 17 at PERFORM
DEBUG:  drop cascades to 2 other objects
DETAIL:  drop cascades to constraint test_table_2_value_1_fkey_2380051 on table test_fkey_to_ref_in_tx.test_table_2_2380051
drop cascades to constraint test_table_2_value_1_fkey_2380053 on table test_fkey_to_ref_in_tx.test_table_2_2380053
DETAIL:  NOTICE from localhost:57637
CONTEXT:  SQL statement "SELECT master_drop_all_shards(v_obj.objid, v_obj.schema_name, v_obj.object_name)"
PL/pgSQL function citus_drop_trigger() line 17 at PERFORM
COMMIT;
RESET client_min_messages;
DROP SCHEMA test_fkey_to_ref_in_tx CASCADE;
NOTICE:  drop cascades to 3 other objects
DETAIL:  drop cascades to table referece_table
drop cascades to table on_update_fkey_table
drop cascades to table unrelated_dist_table
SET search_path TO public;
